#!usr/bin/perl

package Air::Legacy;

# Made by Edoardo Mantovani, 2020
# main Air::Legacy file

use strict;
no strict 'subs';
no strict 'refs';
use warnings;
use Net::MAC; # require Net::MAC library for MAC manipulation

our $VERSION = '00.00';
use base qw(Exporter DynaLoader);


# from: http://www.emcu.eu/wifi-802-11-association-disassociation-reason-code/
my %dissociation_reason_codes = (
	0 => "reserved",
	1 => "Unspecified reason",
	2 => "Previous authentication no longer valid",
	3 => "Deauthenticated because sending station (STA) is leaving or has left Independent Basic Service Set (IBSS) or ESS",
	4 => "Disassociated due to inactivity",
	5 => "Disassociated because WAP device is unable to handle all currently associated STAs",
	6 => "Class 2 frame received from nonauthenticated STA",
	7 => "Class 3 frame received from nonassociated STA",
	8 => "Disassociated because sending STA is leaving or has left Basic Service Set (BSS)",
	9 => "STA requesting (re)association is not authenticated with responding STA",
	10 => "Disassociated because the information in the Power Capability element is unacceptable",
	11 => "Disassociated because the information in the Supported Channels element is unacceptable",
	12 => "Disassociated due to BSS Transition Management",
	13 => "Invalid element, that is, an element defined in this standard for which the content does not meet the specifications in Clause 8", 
	14 => "Message integrity code (MIC) failure", 
	15 => "4-Way Handshake timeout",
	16 => "Group Key Handshake timeout", 
	17 => "Element in 4-Way Handshake different from (Re)Association Request/ Probe Response/Beacon frame",
	18 => "Invalid group cipher",
	19 => "Invalid pairwise cipher",
	20 => "Invalid AKMP",
	21 => "Unsupported RSNE version",
	22 => "Invalid RSNE capabilities", 
	23 => "IEEE 802.1X authentication failed",
	24 => "Cipher suite rejected because of the security policy",
	32 => "Disassociated for unspecified, QoS-related reason",
	33 => "Disassociated because QAP lacks sufficient bandwidth for this QSTA",
	34 => "Disassociated because excessive number of frames need to be acknowledged, but are not
acknowledged due to AP transmissions and/or poor channel conditions",
	35 => "Disassociated because QSTA is transmitting outside the limits of its TXOPs",
	36 => "Requested from peer QSTA as the QSTA is leaving the QBSS (or resetting)",
	37 => "Requested from peer QSTA as it does not want to use the mechanism",	
	38 => "Requested from peer QSTA as the QSTA received frames using the mechanism for which
a setup is required",
	39 => "Requested from peer QSTA due to timeout",
	40 => "Peer QSTA does not support the requested cipher suite"
);

my %association_reason_codes = (

	0 => "Successful",
	1 => "Unspecified failure",
	10 => "Cannot support all requested capabilities in the Capability Information field",
	11 => "Reassociation denied due to inability to confirm that association exists",
	12 => "Association denied due to reason outside the scope of this standard",
	13 => "Responding station does not support the specified authentication algorithm",
	14 => "Received an Authentication frame with authentication transaction sequence number
out of expected sequence",
	15 => "Authentication rejected because of challenge failure",
	16 => "Authentication rejected due to timeout waiting for next frame in sequence",
	17 => "Association denied because AP is unable to handle additional associated stations",
	18 => "Association denied due to requesting station not supporting all of the data rates in the
BSSBasicRateSet parameter",
	19 => "Association denied due to requesting station not supporting the short preamble
option",
	20 => "Association denied due to requesting station not supporting the PBCC modulation
option	",
	21 => "Association denied due to requesting station not supporting the Channel Agility
option",
	22 => "	Association request rejected because Spectrum Management capability is required",
	23 => "Association request rejected because the information in the Power Capability
element is unacceptable",
	24 => "Association request rejected because the information in the Supported Channels
element is unacceptable",
	25 => "Association denied due to requesting station not supporting the Short Slot Time
option",
	26 => "Association denied due to requesting station not supporting the DSSS-OFDM option",
	27 => "Reserved",
	32 => "Unspecified, QoS-related failure",
	33 => "Association denied because QAP has insufficient bandwidth to handle another QSTA",
	34 => "Association denied due to excessive frame loss rates and/or poor conditions on current
operating channel",
	35 => "Association (with QBSS) denied because the requesting STA does not support the QoS facility",
	36 => "Reserved in 802.11",
	37 => "The request has been declined",
	38 => "The request has not been successful as one or more parameters have invalid values",
	39 => "The TS has not been created because the request cannot be honored; however, a suggested
TSPEC is provided so that the initiating QSTA may attempt to set another TS with the suggested changes to the TSPEC",
	40 => "Invalid information element, i.e., an information element defined in this standard for
which the content does not meet the specifications in Clause 7",
	41 => "Invalid group cipher",
	42 => "Invalid pairwise cipher",
	43 => "Invalid AKMP",
	44 => "Unsupported RSN information element version",
	45 => "Invalid RSN information element capabilities",
	46 => "Cipher suite rejected because of security policy",
	47 => "The TS has not been created; however, the HC may be capable of creating a TS, in
response to a request, after the time indicated in the TS Delay element	",
	48 => "Direct link is not allowed in the BSS by policy",
	49 => "Destination STA is not present within this QBSS",
	50 => "The Destination STA is not a QSTA",
	51 => "Association denied because the ListenInterval is too large",
	0xC8 => "Unspecified, QoS-related failure.
Not defined in IEEE, defined in CCXv4",
	0xC9 => "TSPEC request refused due to APâ€™s policy configuration (e.g., AP is configured to deny all TSPEC requests on this SSID). A TSPEC will not be suggested by the AP for this reason code.
Not defined in IEEE, defined in CCXv4",
	0xCA => "Association Denied due to AP having insufficient bandwidth to handle a new TS. This cause code will be useful while roaming only",
	0xCB => "Invalid Parameters. The request has not been successful as one or more TSPEC parameters in the request have invalid values. A TSPEC SHALL be present in the response as a suggestion.",


);
# Defining cipher suites and akm suites
use constant {
	WEP40 => "00-0F-AC-01",
 	WEP104 => "00-0F-AC-05",
	CCMP => "00-0F-AC-04",
	TKIP => "00-0F-AC-02",
	EAP => "00-0F-AC-01",
	PSK => "00-0F-AC-02",
	WPA3 => "00-0F-AC-08",
	PSK_SHA256 => "00-0F-AC-06",
};

use constant {
	LINUX_WLEXT_MONITOR => 6,
	LINUX_WLEXT_MASTER => 3,
	IW_MAX_PRIV_DEF => 128,
};


use constant {
   FAKE_RADIO_TAP_HEADER => '\0\0\0\0',
   TAG_SUPPORTED_RATES => '\x01\x08\x02\x04\x0b\x16\x0c\x12\x18\x24',
   TAG_EXT_RATES => '\x32\x04\x30\x48\x60\x6c',
   TAG_HT_CAPS => '\x2d\x1a\x72\x01\x13\xff\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
   WPS_PROBE_IE => '\xdd\x09\x00\x50\xf2\x04\x10\x4a\x00\x01\x10',
   WPS_VENDOR_ID => '\x00\x50\xF2\x04',
   WPS_DEVICE_TYPE => '\x00\x01\x00\x50\xF2\x04\x00\x01',
   WPS_OS_VERSION => '\x01\x00\x06\x00',
   DEFAULT_UUID => '\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F',
   WFA_REGISTRAR => "WFA-SimpleConfig-Registrar-1-0",
   WPA_IE_ID => '\x00\x50\xF2\x01\x01\x00',
   WFA_VENDOR_ID => '\x00\x37\x2A',
   NULL_MAC => '\x00\x00\x00\x00\x00\x00',
   WPS_REGISTRAR_TAG => '\x00\x50\xF2\x04\x10\x4A\x00\x01\x10\x10\x3A\x00\x01\x02',
   WPS_REGISTRAR_TAG => '\x00\x50\xF2\x04\x10\x4A\x00\x01\x10\x10\x3A\x00\x01\x02',
};

# NOTE: 
# these wifi_commands constants  are supported for the Intel Centrino Advanced-N 6200 network card
use constant {
	get_wiphy =>   "0x1",
	set_wiphy =>   "0x2",
	new_wiphy =>    "0x3",
	del_wiphy =>   "0x4",
	get_interface =>   "0x5",
	set_interface =>   "0x6",
	new_interface =>   "0x7",
	del_interface =>   "0x8",
	get_key =>   "0x9",
	set_key =>   "0xa",
	new_key =>   "0xb",
	del_key =>   "0xc",
	get_beacon =>   "0xd",
	set_beacon =>   "0xe",
	start_ap =>   "0xf",
	stop_ap =>   "0x10",
	get_station =>   "0x11",
	set_station =>   "0x12",
	new_station =>   "0x13",
	del_station =>   "0x14",
	get_mpath =>   "0x15",
	set_mpath =>   "0x16",
	new_mpath =>   "0x17",
	del_mpath =>   "0x18",
	set_bss =>   "0x19",
	set_reg =>   "0x1a",
	req_set_reg =>   "0x1b",
	get_mesh_config =>   "0x1c",
	set_mesh_config =>   "0x1d",
	get_reg =>   "0x1f",
	get_scan =>   "0x20",
	trigger_scan =>   "0x21",
	new_scan_results =>   "0x22",
	scan_aborted =>   "0x23",
	reg_change =>   "0x24",
	authenticate =>   "0x25",
	associate =>   "0x26",
	deauthenticate =>   "0x27",
	disassociate =>   "0x28",
	michael_mic_failure =>   "0x29",
	reg_beacon_hint =>   "0x2a",
	join_ibss =>   "0x2b",
	leave_ibss =>   "0x2c",
	testmode =>   "0x2d",
	connect =>   "0x2e",
	roam =>   "0x2f",
	disconnect =>   "0x30",
	set_wiphy_netns =>   "0x31",
	get_survey =>   "0x32",
	new_survey_results =>   "0x33",
	set_pmksa =>   "0x34",
	del_pmksa =>   "0x35",
	flush_pmksa =>   "0x36",
	remain_on_channel =>   "0x37",
	cancel_remain_on_channel =>   "0x38",
	set_tx_bitrate_mask =>   "0x39",
	register_frame =>   "0x3a",
	frame =>   "0x3b",
	frame_tx_status =>   "0x3c",
	set_power_save =>   "0x3d",
	get_power_save =>   "0x3e",
	set_cqm =>   "0x3f",
	notify_cqm =>   "0x40",
	set_channel =>   "0x41",
	set_wds_peer =>   "0x42",
	frame_wait_cancel =>   "0x43",
	join_mesh =>   "0x44",
	leave_mesh =>   "0x45",
	unprot_deauthenticate =>   "0x46",
	unprot_disassociate =>   "0x47",
	new_peer_candidate =>   "0x48",
	get_wowlan =>   "0x49",
	set_wowlan =>   "0x4a",
	start_sched_scan =>   "0x4b",
	stop_sched_scan =>   "0x4c",
	sched_scan_results =>   "0x4d",
	sched_scan_stopped =>   "0x4e",
	set_rekey_offload =>   "0x4f",
	pmksa_candidate =>   "0x50",
	tdls_oper =>   "0x51",
	tdls_mgmt =>   "0x52",
	unexpected_frame =>   "0x53",
	probe_client =>   "0x54",
	register_beacons =>   "0x55",
	unexpected_4addr_frame =>   "0x56",
	set_noack_map =>   "0x57",
	ch_switch_notify =>   "0x58",
	start_p2p_device =>   "0x59",
	stop_p2p_device =>   "0x5a",
	conn_failed =>   "0x5b",
	set_mcast_rate =>   "0x5c",
	set_mac_acl =>   "0x5d",
	radar_detect =>   "0x5e",
	get_protocol_features =>   "0x5f",
	update_ft_ies =>   "0x60",
	ft_event =>   "0x61",
	crit_protocol_start =>   "0x62",
	crit_protocol_stop =>   "0x63",
	get_coalesce =>   "0x64",
	set_coalesce =>   "0x65",
	channel_switch =>   "0x66",
	vendor =>   "0x67",
};

my %channel_to_frequency = (
    1 => 2412,
    2 => 2417,
    3 => 2422,
    4 => 2427,
    5 => 2432,
    6 => 2437,
    7 => 2442,
    8 => 2447,
    9 => 2452,
   10 => 2457,
   11 => 2462,
   12 => 2467,
   13 => 2472,
   14 => 2484,
   36 => 5180,
   38 => 5190,
   40 => 5200,
   42 => 5210,
   44 => 5220,
   46 => 5230,
   48 => 5240,
   50 => 5250,
   52 => 5260,
   54 => 5270,
   56 => 5280,
   58 => 5290,
   60 => 5300,
   62 => 5310,
   64 => 5320,
  100 => 5500,
  102 => 5510,
  104 => 5520,
  106 => 5530,
  108 => 5540,
  110 => 5550,
  112 => 5560,
  114 => 5570,
  116 => 5580,
  118 => 5590,
  120 => 5600,
  122 => 5610,
  124 => 5620,
  126 => 5630,
  128 => 5640,
  132 => 5660,
  134 => 5670,
  136 => 5680,
  138 => 5690,
  140 => 5700,
  142 => 5710,
  144 => 5720,
  149 => 5745,
  151 => 5755,
  153 => 5765,
  155 => 5775,
  157 => 5785,
  159 => 5795,
  161 => 5805,
  165 => 5825,
);

use constant {
	IBSS => "\x40\xb0\xc0\xd0",
	managed => "\x40\xd0",
	AP => "\x00\x20\x40\xa0\xb0\xc0\xd0",
	VLAN => "\x00\x20\x40\xa0\xb0\xc0\xd0",
	mesh_point => "\xb0\xc0\xd0",
	P2P_CLIENT => "\x40\xd0", 
	P2P_GO => "\x00\x20\x40\xa0\0xb0\0xc0\xd0",
	P2P_DEV => "\x40\xd0",
};

use constant {
    WEP_CRC_TABLE =>[ qw /   
    0x00000000 0x77073096 0xee0e612c 0x990951ba 0x076dc419
    0x706af48f 0xe963a535 0x9e6495a3 0x0edb8832 0x79dcb8a4
    0xe0d5e91e 0x97d2d988 0x09b64c2b 0x7eb17cbd 0xe7b82d07
    0x90bf1d91 0x1db71064 0x6ab020f2 0xf3b97148 0x84be41de
    0x1adad47d 0x6ddde4eb 0xf4d4b551 0x83d385c7 0x136c9856
    0x646ba8c0 0xfd62f97a 0x8a65c9ec 0x14015c4f 0x63066cd9
    0xfa0f3d63 0x8d080df5 0x3b6e20c8 0x4c69105e 0xd56041e4
    0xa2677172 0x3c03e4d1 0x4b04d447 0xd20d85fd 0xa50ab56b
    0x35b5a8fa 0x42b2986c 0xdbbbc9d6 0xacbcf940 0x32d86ce3
    0x45df5c75 0xdcd60dcf 0xabd13d59 0x26d930ac 0x51de003a
    0xc8d75180 0xbfd06116 0x21b4f4b5 0x56b3c423 0xcfba9599
    0xb8bda50f 0x2802b89e 0x5f058808 0xc60cd9b2 0xb10be924
    0x2f6f7c87 0x58684c11 0xc1611dab 0xb6662d3d 0x76dc4190
    0x01db7106 0x98d220bc 0xefd5102a 0x71b18589 0x06b6b51f
    0x9fbfe4a5 0xe8b8d433 0x7807c9a2 0x0f00f934 0x9609a88e
    0xe10e9818 0x7f6a0dbb 0x086d3d2d 0x91646c97 0xe6635c01
    0x6b6b51f4 0x1c6c6162 0x856530d8 0xf262004e 0x6c0695ed
    0x1b01a57b 0x8208f4c1 0xf50fc457 0x65b0d9c6 0x12b7e950
    0x8bbeb8ea 0xfcb9887c 0x62dd1ddf 0x15da2d49 0x8cd37cf3
    0xfbd44c65 0x4db26158 0x3ab551ce 0xa3bc0074 0xd4bb30e2
    0x4adfa541 0x3dd895d7 0xa4d1c46d 0xd3d6f4fb 0x4369e96a
    0x346ed9fc 0xad678846 0xda60b8d0 0x44042d73 0x33031de5
    0xaa0a4c5f 0xdd0d7cc9 0x5005713c 0x270241aa 0xbe0b1010
    0xc90c2086 0x5768b525 0x206f85b3 0xb966d409 0xce61e49f
    0x5edef90e 0x29d9c998 0xb0d09822 0xc7d7a8b4 0x59b33d17
    0x2eb40d81 0xb7bd5c3b 0xc0ba6cad 0xedb88320 0x9abfb3b6
    0x03b6e20c 0x74b1d29a 0xead54739 0x9dd277af 0x04db2615
    0x73dc1683 0xe3630b12 0x94643b84 0x0d6d6a3e 0x7a6a5aa8
    0xe40ecf0b 0x9309ff9d 0x0a00ae27 0x7d079eb1 0xf00f9344
    0x8708a3d2 0x1e01f268 0x6906c2fe 0xf762575d 0x806567cb
    0x196c3671 0x6e6b06e7 0xfed41b76 0x89d32be0 0x10da7a5a
    0x67dd4acc 0xf9b9df6f 0x8ebeeff9 0x17b7be43 0x60b08ed5
    0xd6d6a3e8 0xa1d1937e 0x38d8c2c4 0x4fdff252 0xd1bb67f1
    0xa6bc5767 0x3fb506dd 0x48b2364b 0xd80d2bda 0xaf0a1b4c
    0x36034af6 0x41047a60 0xdf60efc3 0xa867df55 0x316e8eef
    0x4669be79 0xcb61b38c 0xbc66831a 0x256fd2a0 0x5268e236
    0xcc0c7795 0xbb0b4703 0x220216b9 0x5505262f 0xc5ba3bbe
    0xb2bd0b28 0x2bb45a92 0x5cb36a04 0xc2d7ffa7 0xb5d0cf31
    0x2cd99e8b 0x5bdeae1d 0x9b64c2b0 0xec63f226 0x756aa39c
    0x026d930a 0x9c0906a9 0xeb0e363f 0x72076785 0x05005713
    0x95bf4a82 0xe2b87a14 0x7bb12bae 0x0cb61b38 0x92d28e9b
    0xe5d5be0d 0x7cdcefb7 0x0bdbdf21 0x86d3d2d4 0xf1d4e242
    0x68ddb3f8 0x1fda836e 0x81be16cd 0xf6b9265b 0x6fb077e1
    0x18b74777 0x88085ae6 0xff0f6a70 0x66063bca 0x11010b5c
    0x8f659eff 0xf862ae69 0x616bffd3 0x166ccf45 0xa00ae278
    0xd70dd2ee 0x4e048354 0x3903b3c2 0xa7672661 0xd06016f7
    0x4969474d 0x3e6e77db 0xaed16a4a 0xd9d65adc 0x40df0b66
    0x37d83bf0 0xa9bcae53 0xdebb9ec5 0x47b2cf7f 0x30b5ffe9
    0xbdbdf21c 0xcabac28a 0x53b39330 0x24b4a3a6 0xbad03605
    0xcdd70693 0x54de5729 0x23d967bf 0xb3667a2e 0xc4614ab8
    0x5d681b02 0x2a6f2b94 0xb40bbe37 0xc30c8ea1 0x5a05df1b
    0x2d02ef8d / ],
    
};

use constant {
	SIOCSIWNAME=> "0x8B00",
	SIOCGIWNAME=> "0x8B01",
	SIOCSIWNWID=> "0x8B02",
	SIOCGIWNWID=> "0x8B03",
	SIOCSIWFREQ=> "0x8B04",
	SIOCGIWFREQ=> "0x8B05",
	SIOCSIWMODE=> "0x8B06",
	SIOCGIWMODE=> "0x8B07",
	SIOCSIWSENS=> "0x8B08",
	SIOCGIWSENS=> "0x8B09",
	SIOCSIWRANGE=> "0x8B0A",
	SIOCGIWRANGE=> "0x8B0B",
	SIOCSIWPRIV=> "0x8B0C",
	SIOCGIWPRIV=> "0x8B0D",
	SIOCSIWSPY=> "0x8B10",
	SIOCGIWSPY=> "0x8B11",
	SIOCSIWAP=> "0x8B14",
	SIOCGIWAP=> "0x8B15",
	SIOCGIWAPLIST=> "0x8B17",
	SIOCSIWESSID=> "0x8B1A",
	SIOCGIWESSID=> "0x8B1B",
	SIOCSIWNICKN=> "0x8B1C",
	SIOCGIWNICKN=> "0x8B1D",
	SIOCSIWRATE=> "0x8B20",
	SIOCGIWRATE=> "0x8B21",
	SIOCSIWRTS=> "0x8B22",
	SIOCGIWRTS=> "0x8B23",
	SIOCSIWFRAG=> "0x8B24",
	SIOCGIWFRAG=> "0x8B25",
	SIOCSIWTXPOW=> "0x8B26",
	SIOCGIWTXPOW=> "0x8B27",
	SIOCSIWENCODE=> "0x8B2A",
	SIOCGIWENCODE=> "0x8B2B",
	SIOCSIWPOWER=> "0x8B2C",
	SIOCGIWPOWER=> "0x8B2D",
	SIOCIWFIRST=> "0x8B00",
	SIOCIWLAST=> "0x8B30",
};

use constant {
	NULL => "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
};

use constant {
	IEEE80211_MIN_AMPDU_BUF=> "0x8",
	IEEE80211_MAX_AMPDU_BUF=> "0x40",
	IEEE80211_HT_PARAM_CHA_SEC_OFFSET=> "0x03",
	IEEE80211_HT_PARAM_CHA_SEC_NONE=> "0x00",
	IEEE80211_HT_PARAM_CHA_SEC_ABOVE=> "0x01",
	IEEE80211_HT_PARAM_CHA_SEC_BELOW=> "0x03",
	IEEE80211_HT_PARAM_CHAN_WIDTH_ANY=> "0x04",
	IEEE80211_HT_PARAM_RIFS_MODE=> "0x08",
	IEEE80211_HT_OP_MODE_PROTECTION=> "0x0003",
	IEEE80211_HT_OP_MODE_PROTECTION_NONE=> "0",
	IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER=> "1",
	IEEE80211_HT_OP_MODE_PROTECTION_20MHZ=> "2",
	IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED=> "3",
	IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT=> "0x0004",
	IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT=> "0x0010",
	IEEE80211_HT_OP_MODE_CCFS2_SHIFT=> "5",
	IEEE80211_HT_OP_MODE_CCFS2_MASK=> "0x1fe0",
	IEEE80211_HT_STBC_PARAM_DUAL_BEACON=> "0x0040",
	IEEE80211_HT_STBC_PARAM_DUAL_CTS_PROT=> "0x0080",
	IEEE80211_HT_STBC_PARAM_STBC_BEACON=> "0x0100",
	IEEE80211_HT_STBC_PARAM_LSIG_TXOP_FULLPROT=> "0x0200",
	IEEE80211_HT_STBC_PARAM_PCO_ACTIVE=> "0x0400",
	IEEE80211_HT_STBC_PARAM_PCO_PHASE=> "0x0800",
	IEEE80211_ADDBA_PARAM_AMSDU_MASK=> "0x0001",
	IEEE80211_ADDBA_PARAM_POLICY_MASK=> "0x0002",
	IEEE80211_ADDBA_PARAM_TID_MASK=> "0x003C",
	IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK=> "0xFFC0",
	IEEE80211_DELBA_PARAM_TID_MASK=> "0xF000",
	IEEE80211_DELBA_PARAM_INITIATOR_MASK=> "0x0800",
	IEEE80211_HT_CAP_LDPC_CODING=> "0x0001",
	IEEE80211_HT_CAP_SUP_WIDTH_20_40=> "0x0002",
	IEEE80211_HT_CAP_SM_PS=> "0x000C",
	IEEE80211_HT_CAP_SM_PS_SHIFT=> "2",
	IEEE80211_HT_CAP_GRN_FLD=> "0x0010",
	IEEE80211_HT_CAP_SGI_20=> "0x0020",
	IEEE80211_HT_CAP_SGI_40=> "0x0040",
	IEEE80211_HT_CAP_TX_STBC=> "0x0080",
	IEEE80211_HT_CAP_RX_STBC=> "0x0300",
	IEEE80211_HT_CAP_RX_STBC_SHIFT=> "8",
	IEEE80211_HT_CAP_DELAY_BA=> "0x0400",
	IEEE80211_HT_CAP_MAX_AMSDU=> "0x0800",
	IEEE80211_HT_CAP_DSSSCCK40=> "0x1000",
	IEEE80211_HT_CAP_RESERVED=> "0x2000",
	IEEE80211_HT_CAP_40MHZ_INTOLERANT=> "0x4000",
	IEEE80211_HT_CAP_LSIG_TXOP_PROT=> "0x8000",
	IEEE80211_HT_EXT_CAP_PCO=> "0x0001",
	IEEE80211_HT_EXT_CAP_PCO_TIME=> "0x0006",
	IEEE80211_HT_EXT_CAP_PCO_TIME_SHIFT=> "1",
	IEEE80211_HT_EXT_CAP_MCS_FB=> "0x0300",
	IEEE80211_HT_EXT_CAP_MCS_FB_SHIFT=> "8",
	IEEE80211_HT_EXT_CAP_HTC_SUP=> "0x0400",
	IEEE80211_HT_EXT_CAP_RD_RESPONDER=> "0x0800",
	IEEE80211_FCTL_VERS=> "0x0003",
	IEEE80211_FCTL_FTYPE=> "0x000c",
	IEEE80211_FCTL_STYPE=> "0x00f0",
	IEEE80211_FCTL_TODS=> "0x0100",
	IEEE80211_FCTL_FROMDS=> "0x0200",
	IEEE80211_FCTL_MOREFRAGS=> "0x0400",
	IEEE80211_FCTL_RETRY=> "0x0800",
	IEEE80211_FCTL_PM=> "0x1000",
	IEEE80211_FCTL_MOREDATA=> "0x2000",
	IEEE80211_FCTL_PROTECTED=> "0x4000",
	IEEE80211_FCTL_ORDER=> "0x8000",
	IEEE80211_FCTL_CTL_EXT=> "0x0f00",
	IEEE80211_SCTL_FRAG=> "0x000F",
	IEEE80211_SCTL_SEQ=> "0xFFF0",
	IEEE80211_FTYPE_MGMT=> "0x0000",
	IEEE80211_FTYPE_CTL=> "0x0004",
	IEEE80211_FTYPE_DATA=> "0x0008",
	IEEE80211_FTYPE_EXT=> "0x000c",
	IEEE80211_STYPE_ASSOC_REQ=> "0x0000",
	IEEE80211_STYPE_ASSOC_RESP=> "0x0010",
	IEEE80211_STYPE_REASSOC_REQ=> "0x0020",
	IEEE80211_STYPE_REASSOC_RESP=> "0x0030",
	IEEE80211_STYPE_PROBE_REQ=> "0x0040",
	IEEE80211_STYPE_PROBE_RESP=> "0x0050",
	IEEE80211_STYPE_BEACON=> "0x0080",
	IEEE80211_STYPE_ATIM=> "0x0090",
	IEEE80211_STYPE_DISASSOC=> "0x00A0",
	IEEE80211_STYPE_AUTH=> "0x00B0",
	IEEE80211_STYPE_DEAUTH=> "0x00C0",
	IEEE80211_STYPE_ACTION=> "0x00D0",
	IEEE80211_STYPE_CTL_EXT=> "0x0060",
	IEEE80211_STYPE_BACK_REQ=> "0x0080",
	IEEE80211_STYPE_BACK=> "0x0090",
	IEEE80211_STYPE_PSPOLL=> "0x00A0",
	IEEE80211_STYPE_RTS=> "0x00B0",
	IEEE80211_STYPE_CTS=> "0x00C0",
	IEEE80211_STYPE_ACK=> "0x00D0",
	IEEE80211_STYPE_CFEND=> "0x00E0",
	IEEE80211_STYPE_CFENDACK=> "0x00F0",
	IEEE80211_STYPE_DATA=> "0x0000",
	IEEE80211_STYPE_DATA_CFACK=> "0x0010",
	IEEE80211_STYPE_DATA_CFPOLL=> "0x0020",
	IEEE80211_STYPE_DATA_CFACKPOLL=> "0x0030",
	IEEE80211_STYPE_NULLFUNC=> "0x0040",
	IEEE80211_STYPE_CFACK=> "0x0050",
	IEEE80211_STYPE_CFPOLL=> "0x0060",
	IEEE80211_STYPE_CFACKPOLL=> "0x0070",
	IEEE80211_STYPE_QOS_DATA=> "0x0080",
	IEEE80211_STYPE_QOS_DATA_CFACK=> "0x0090",
	IEEE80211_STYPE_QOS_DATA_CFPOLL=> "0x00A0",
	IEEE80211_STYPE_QOS_DATA_CFACKPOLL=> "0x00B0",
	IEEE80211_STYPE_QOS_NULLFUNC=> "0x00C0",
	IEEE80211_STYPE_QOS_CFACK=> "0x00D0",
	IEEE80211_STYPE_QOS_CFPOLL=> "0x00E0",
	IEEE80211_STYPE_QOS_CFACKPOLL=> "0x00F0",
	IEEE80211_STYPE_DMG_BEACON=> "0x0000",
	IEEE80211_CTL_EXT_POLL=> "0x2000",
	IEEE80211_CTL_EXT_SPR=> "0x3000",
	IEEE80211_CTL_EXT_GRANT=> "0x4000",
	IEEE80211_CTL_EXT_DMG_CTS=> "0x5000",
	IEEE80211_CTL_EXT_DMG_DTS=> "0x6000",
	IEEE80211_CTL_EXT_SSW=> "0x8000",
	IEEE80211_CTL_EXT_SSW_FBACK=> "0x9000",
	IEEE80211_CTL_EXT_SSW_ACK=> "0xa000",
	WLAN_MAX_KEY_LEN=> "32",
	WLAN_PMK_NAME_LEN=> "16",
	WLAN_PMKID_LEN=> "16",
	WLAN_PMK_LEN_EAP_LEAP=> "16",
	WLAN_PMK_LEN=> "32",
	WLAN_PMK_LEN_SUITE_B_192=> "48",
	WLAN_OUI_WFA=> "0x506f9a",
	WLAN_OUI_TYPE_WFA_P2P=> "9",
	WLAN_OUI_MICROSOFT=> "0x0050f2",
	WLAN_OUI_TYPE_MICROSOFT_WPA=> "1",
	WLAN_OUI_TYPE_MICROSOFT_WMM=> "2",
	WLAN_OUI_TYPE_MICROSOFT_WPS=> "4",
	WLAN_OUI_TYPE_MICROSOFT_TPC=> "8",
	IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895=> "0x00000000",
	IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991=> "0x00000001",
	IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454=> "0x00000002",
	IEEE80211_VHT_CAP_MAX_MPDU_MASK=> "0x00000003",
	IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ=> "0x00000004",
	IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ=> "0x00000008",
	IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK=> "0x0000000C",
	IEEE80211_VHT_CAP_RXLDPC=> "0x00000010",
	IEEE80211_VHT_CAP_SHORT_GI_80=> "0x00000020",
	IEEE80211_VHT_CAP_SHORT_GI_160=> "0x00000040",
	IEEE80211_VHT_CAP_TXSTBC=> "0x00000080",
	IEEE80211_VHT_CAP_RXSTBC_1=> "0x00000100",
	IEEE80211_VHT_CAP_RXSTBC_2=> "0x00000200",
	IEEE80211_VHT_CAP_RXSTBC_3=> "0x00000300",
	IEEE80211_VHT_CAP_RXSTBC_4=> "0x00000400",
	IEEE80211_VHT_CAP_RXSTBC_MASK=> "0x00000700",
	IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE=> "0x00000800",
	IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE=> "0x00001000",
	IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT=> "13",
	IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT=> "16",
	IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE=> "0x00080000",
	IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE=> "0x00100000",
	IEEE80211_VHT_CAP_VHT_TXOP_PS=> "0x00200000",
	IEEE80211_VHT_CAP_HTC_VHT=> "0x00400000",
	IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT=> "23",
	IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_UNSOL_MFB=> "0x08000000",
	IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB=> "0x0c000000",
	IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN=> "0x10000000",
	IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN=> "0x20000000",
};

use constant {
	IF_GET_IFACE=> "0x0001",
	IF_GET_PROTO=> "0x0002",
	IF_IFACE_V35=> "0x1000",
	IF_IFACE_V24=> "0x1001",
	IF_IFACE_X21=> "0x1002",
	IF_IFACE_T1=> "0x1003",
	IF_IFACE_E1=> "0x1004",
	IF_IFACE_SYNC_SERIAL=> "0x1005",
	IF_IFACE_X21D=> "0x1006",
	IF_PROTO_HDLC=> "0x2000",
	IF_PROTO_PPP=> "0x2001",
	IF_PROTO_CISCO=> "0x2002",
	IF_PROTO_FR=> "0x2003",
	IF_PROTO_FR_ADD_PVC=> "0x2004",
	IF_PROTO_FR_DEL_PVC=> "0x2005",
	IF_PROTO_X25=> "0x2006",
	IF_PROTO_HDLC_ETH=> "0x2007",
	IF_PROTO_FR_ADD_ETH_PVC=> "0x2008",
	IF_PROTO_FR_DEL_ETH_PVC=> "0x2009",
	IF_PROTO_FR_PVC=> "0x200A",
	IF_PROTO_FR_ETH_PVC=> "0x200B",
	IF_PROTO_RAW=> "0x200C",
	ICMP_ECHOREPLY=> "0",
	ICMP_DEST_UNREACH=> "3",
	ICMP_SOURCE_QUENCH=> "4",
	ICMP_REDIRECT=> "5",
	ICMP_ECHO=> "8",
	ICMP_TIME_EXCEEDED=> "11",
	ICMP_PARAMETERPROB=> "12",
	ICMP_TIMESTAMP=> "13",
	ICMP_TIMESTAMPREPLY=> "14",
	ICMP_INFO_REQUEST=> "15",
	ICMP_INFO_REPLY=> "16",
	ICMP_ADDRESS=> "17",
	ICMP_ADDRESSREPLY=> "18",
	NR_ICMP_TYPES=> "18",
	ICMP_NET_UNREACH=> "0",
	ICMP_HOST_UNREACH=> "1",
	ICMP_PROT_UNREACH=> "2",
	ICMP_PORT_UNREACH=> "3",
	ICMP_FRAG_NEEDED=> "4",
	ICMP_SR_FAILED=> "5",
	ICMP_NET_UNKNOWN=> "6",
	ICMP_HOST_UNKNOWN=> "7",
	ICMP_HOST_ISOLATED=> "8",
	ICMP_NET_ANO=> "9",
	ICMP_HOST_ANO=> "10",
	ICMP_NET_UNR_TOS=> "11",
	ICMP_HOST_UNR_TOS=> "12",
	ICMP_PKT_FILTERED=> "13",
	ICMP_PREC_VIOLATION=> "14",
	ICMP_PREC_CUTOFF=> "15",
	NR_ICMP_UNREACH=> "15",
	ICMP_REDIR_NET=> "0",
	ICMP_REDIR_HOST=> "1",
	ICMP_REDIR_NETTOS=> "2",
	ICMP_REDIR_HOSTTOS=> "3",
	ICMP_EXC_TTL=> "0",
	ICMP_EXC_FRAGTIME=> "1",
	TCP_MSS_DEFAULT=> "536U",
	TCP_MSS_DESIRED=> "1220U",
	TCP_NODELAY=> "1",
	TCP_MAXSEG=> "2",
	TCP_CORK=> "3",
	TCP_KEEPIDLE=> "4",
	TCP_KEEPINTVL=> "5",
	TCP_KEEPCNT=> "6",
	TCP_SYNCNT=> "7",
	TCP_LINGER2=> "8",
	TCP_DEFER_ACCEPT=> "9",
	TCP_WINDOW_CLAMP=> "10",
	TCP_INFO=> "11",
	TCP_QUICKACK=> "12",
	TCP_CONGESTION=> "13",
	TCP_MD5SIG=> "14",
	TCP_THIN_LINEAR_TIMEOUTS=> "16",
	TCP_THIN_DUPACK=> "17",
	TCP_USER_TIMEOUT=> "18",
	TCP_REPAIR=> "19",
	TCP_REPAIR_QUEUE=> "20",
	TCP_QUEUE_SEQ=> "21",
	TCP_REPAIR_OPTIONS=> "22",
	TCP_FASTOPEN=> "23",
	TCP_TIMESTAMP=> "24",
	TCP_NOTSENT_LOWAT=> "25",
	TCP_CC_INFO=> "26",
	TCP_SAVE_SYN=> "27",
	TCP_SAVED_SYN=> "28",
	UDP_CORK=> "1",
	UDP_ENCAP=> "100",
	UDP_NO_CHECK6_TX=> "101",
	UDP_NO_CHECK6_RX=> "102",
	UDP_ENCAP_ESPINUDP_NON_IKE=> "1",
	UDP_ENCAP_ESPINUDP=> "2",
	UDP_ENCAP_L2TPINUDP=> "3",
	IPTOS_TOS_MASK=> "0x1E",
	IPTOS_LOWDELAY=> "0x10",
	IPTOS_THROUGHPUT=> "0x08",
	IPTOS_RELIABILITY=> "0x04",
	IPTOS_MINCOST=> "0x02",
	IPTOS_PREC_MASK=> "0xE0",
	IPTOS_PREC_NETCONTROL=> "0xe0",
	IPTOS_PREC_INTERNETCONTROL=> "0xc0",
	IPTOS_PREC_CRITIC_ECP=> "0xa0",
	IPTOS_PREC_FLASHOVERRIDE=> "0x80",
	IPTOS_PREC_FLASH=> "0x60",
	IPTOS_PREC_IMMEDIATE=> "0x40",
	IPTOS_PREC_PRIORITY=> "0x20",
	IPTOS_PREC_ROUTINE=> "0x00",
	IPOPT_COPY=> "0x80",
	IPOPT_CLASS_MASK=> "0x60",
	IPOPT_NUMBER_MASK=> "0x1f",
	IPOPT_COPY=> "0x80",
	IPOPT_CLASS_MASK=> "0x60",
	IPOPT_NUMBER_MASK=> "0x1f",
	IPOPT_CONTROL=> "0x00",
	IPOPT_RESERVED1=> "0x20",
	IPOPT_MEASUREMENT=> "0x40",
	IPOPT_RESERVED2=> "0x60",
	IPVERSION=> "4",
	MAXTTL=> "255",
	IPDEFTTL=> "64",
	IPOPT_OPTVAL=> "0",
	IPOPT_OLEN=> "1",
	IPOPT_OFFSET=> "2",
	IPOPT_MINOFF=> "4",
	MAX_IPOPTLEN=> "40",
	IPOPT_NOP=> "IPOPT_NOOP",
	IPOPT_EOL=> "IPOPT_END",
	IPOPT_TS=> "IPOPT_TIMESTAMP",
	IPOPT_TS_TSONLY=> "0",
	IPOPT_TS_TSANDADDR=> "1",
	IPOPT_TS_PRESPEC=> "3",
	IPV4_BEET_PHMAXLEN=> "8",
	IPV6_TLV_TNL_ENCAP_LIMIT=> "4",
	IPV6_DEFAULT_TNL_ENCAP_LIMIT=> "4",
	IP6_TNL_F_IGN_ENCAP_LIMIT=> "0x1",
	IP6_TNL_F_USE_ORIG_TCLASS=> "0x2",
	IP6_TNL_F_USE_ORIG_FLOWLABEL=> "0x4",
	IP6_TNL_F_MIP6_DEV=> "0x8",
	IP6_TNL_F_RCV_DSCP_COPY=> "0x10",
	IP6_TNL_F_USE_ORIG_FWMARK=> "0x20",
	IPV6_SRCRT_STRICT=> "0x01",
	IPV6_SRCRT_TYPE_0=> "0",
	IPV6_SRCRT_TYPE_2=> "2",
	IPV6_OPT_ROUTERALERT_MLD=> "0x0000",
	RTF_DEFAULT=> "0x00010000",
	RTF_ALLONLINK=> "0x00020000",
	RTF_ADDRCONF=> "0x00040000",
	RTF_PREFIX_RT=> "0x00080000",
	RTF_ANYCAST=> "0x00100000",
	RTF_NONEXTHOP=> "0x00200000",
	RTF_EXPIRES=> "0x00400000",
	RTF_ROUTEINFO=> "0x00800000",
	RTF_CACHE=> "0x01000000",
	RTF_FLOW=> "0x02000000",
	RTF_POLICY=> "0x04000000",
	RTF_PREF_MASK=> "0x18000000",
	RTF_PCPU=> "0x40000000",
	RTF_LOCAL=> "0x80000000",
	RTMSG_NEWDEVICE=> "0x11",
	RTMSG_DELDEVICE=> "0x12",
	RTMSG_NEWROUTE=> "0x21",
	RTMSG_DELROUTE=> "0x22",
	IP6_RT_PRIO_USER=> "1024",
	IP6_RT_PRIO_ADDRCONF=> "256",

};

use constant {

LORCON_EGENERIC => -1,
LORCON_ENOTSUPP => -255,
LORCON_STATUS_MAX => 1024,
LORCON_MAX_PACKET_LEN => 8192,
LORCON_CHANNEL_BASIC => 0,
LORCON_CHANNEL_HT20 => 1,
LORCON_CHANNEL_HT40P => 2,
LORCON_CHANNEL_HT40M => 3,
LORCON_CHANNEL_5MHZ => 4,
LORCON_CHANNEL_10MHZ => 5,
LORCON_CHANNEL_VHT80 => 6,
LORCON_CHANNEL_VHT160 => 7,
LORCON_CHANNEL_VHT8080 => 8,
  
LORCON_RTAP_CHAN_TURBO => "0x0010",
LORCON_RTAP_CHAN_CCK => "0x0020",
LORCON_RTAP_CHAN_OFDM => "0x0040",
LORCON_RTAP_CHAN_2GHZ => "0x0080",
LORCON_RTAP_CHAN_5GHZ => "0x0100",
LORCON_RTAP_CHAN_PASSIVE => "0x0200",
LORCON_RTAP_CHAN_DYN => "0x0400",
LORCON_RTAP_CHAN_GFSK => "0x0800",
LORCON_RTAP_CHAN_STURBO => "0x2000",

TX_IEEE80211_RADIOTAP_TSFT => 0,
TX_IEEE80211_RADIOTAP_FLAGS => 1,
TX_IEEE80211_RADIOTAP_RATE => 2,
TX_IEEE80211_RADIOTAP_CHANNEL => 3,
TX_IEEE80211_RADIOTAP_FHSS => 4,
TX_IEEE80211_RADIOTAP_DBM_ANTSIGNAL => 5,
TX_IEEE80211_RADIOTAP_DBM_ANTNOISE => 6,
TX_IEEE80211_RADIOTAP_LOCK_QUALITY => 7,
TX_IEEE80211_RADIOTAP_TX_ATTENUATION => 8,
TX_IEEE80211_RADIOTAP_DB_TX_ATTENUATION => 9,
TX_IEEE80211_RADIOTAP_DBM_TX_POWER => 10,
TX_IEEE80211_RADIOTAP_ANTENNA => 11,
TX_IEEE80211_RADIOTAP_DB_ANTSIGNAL => 12,
TX_IEEE80211_RADIOTAP_DB_ANTNOISE => 13,
TX_IEEE80211_RADIOTAP_FCS => 14,
TX_IEEE80211_RADIOTAP_EXT => 31,
    
LORCON_RATE_DEFAULT => 0,
LORCON_RATE_1MB => 2,
LORCON_RATE_2MB => 4,
LORCON_RATE_5_5MB => 11,
LORCON_RATE_6MB => 12,
LORCON_RATE_9MB => 18,
LORCON_RATE_11MB => 22,
LORCON_RATE_12MB => 24,
LORCON_RATE_18MB => 36,
LORCON_RATE_24MB => 48,
LORCON_RATE_36MB => 72,
LORCON_RATE_48MB => 96,
LORCON_RATE_54MB => 108,
LORCON_RATE_108MB => 216,
  
LORCON_PACKET_EXTRA_NONE => 0,
LORCON_PACKET_EXTRA_80211 => 1,
LORCON_PACKET_EXTRA_8023 => 2,
  
WLAN_STATUS_SUCCESS => 0,
WLAN_STATUS_UNSPECIFIED_FAILURE => 1,
WLAN_STATUS_CAPS_UNSUPPORTED => 10,
WLAN_STATUS_REASSOC_NO_ASSOC => 11,
WLAN_STATUS_ASSOC_DENIED_UNSPEC => 12,
WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG => 13,
WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION => 14,
WLAN_STATUS_CHALLENGE_FAIL => 15,
WLAN_STATUS_AUTH_TIMEOUT => 16,
WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA => 17,
WLAN_STATUS_ASSOC_DENIED_RATES => 18,
WLAN_STATUS_ASSOC_DENIED_NOSHORT => 19,
WLAN_STATUS_ASSOC_DENIED_NOPBCC => 20,
WLAN_STATUS_ASSOC_DENIED_NOAGILITY => 21,
WLAN_STATUS_INVALID_IE => 40,
WLAN_STATUS_GROUP_CIPHER_NOT_VALID => 41,
WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID => 42,
WLAN_STATUS_AKMP_NOT_VALID => 43,
WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION => 44,
WLAN_STATUS_INVALID_RSN_IE_CAPAB => 45,
WLAN_STATUS_CIPHER_REJECTED_PER_POLICY => 46,
  
WLAN_FC_SUBTYPE_ASSOCREQ => 0,
WLAN_FC_SUBTYPE_ASSOCRESP => 1,
WLAN_FC_SUBTYPE_REASSOCREQ => 2,
WLAN_FC_SUBTYPE_REASSOCRESP => 3,
WLAN_FC_SUBTYPE_PROBEREQ => 4,
WLAN_FC_SUBTYPE_PROBERESP => 5,
WLAN_FC_SUBTYPE_BEACON => 8,
WLAN_FC_SUBTYPE_ATIM => 9,
WLAN_FC_SUBTYPE_DISASSOC => 10,
WLAN_FC_SUBTYPE_AUTH => 11,
WLAN_FC_SUBTYPE_DEAUTH => 12,

LORCON_DOT11_DIR_FROMDS => 1,
LORCON_DOT11_DIR_TODS => 2,
LORCON_DOT11_DIR_INTRADS => 3,
LORCON_DOT11_DIR_ADHOCDS => 4,


WIFI_WIDTH_MASK => "0x0000FFFF",
WIFI_HT_MASK => "0x00FF0000",
WIFI_OTHER_MASK => "0xFF000000",

};

# status and requests tags are from ie80211 file 

our %EXPORT_TAGS = (
   consts => [qw(
      WEP_CRC_TABLE
      LORCON_EGENERIC
      LORCON_ENOTSUPP
      LORCON_STATUS_MAX
      LORCON_MAX_PACKET_LEN
   )],
  rx_frames => [qw(
      IBSS
      managed
      AP
      VLAN
      mesh_point
      P2P_CLIENT
      P2P_GO
      P2P_DEV
  )],
  
  ioctls => [qw(
	SIOCSIWNAME
	SIOCGIWNAME
	SIOCSIWNWID
	SIOCGIWNWID
	SIOCSIWFREQ
	SIOCGIWFREQ
	SIOCSIWMODE
	SIOCGIWMODE
	SIOCSIWSENS
	SIOCGIWSENS
	SIOCSIWRANGE
	SIOCGIWRANGE
	SIOCSIWPRIV
	SIOCGIWPRIV
	SIOCSIWSPY
	SIOCGIWSPY
	SIOCSIWAP
	SIOCGIWAP
	SIOCGIWAPLIST
	SIOCSIWESSID
	SIOCGIWESSID
	SIOCSIWNICKN
	SIOCGIWNICKN
	SIOCSIWRATE
	SIOCGIWRATE
	SIOCSIWRTS
	SIOCGIWRTS
	SIOCSIWFRAG
	SIOCGIWFRAG
	SIOCSIWTXPOW
	SIOCGIWTXPOW
	SIOCSIWENCODE
	SIOCGIWENCODE
	SIOCSIWPOWER
	SIOCGIWPOWER
	SIOCIWFIRST
	SIOCIWLAST  
  )],
  
  radiotap => [qw(
      LORCON_RTAP_CHAN_TURBO
      LORCON_RTAP_CHAN_CCK
      LORCON_RTAP_CHAN_OFDM
      LORCON_RTAP_CHAN_2GHZ
      LORCON_RTAP_CHAN_5GHZ
      LORCON_RTAP_CHAN_PASSIVE
      LORCON_RTAP_CHAN_DYN
      LORCON_RTAP_CHAN_GFSK
      LORCON_RTAP_CHAN_STURBO
)],
  
  tx_80211 => [qw(
  	  TX_IEEE80211_RADIOTAP_TSFT 
	  TX_IEEE80211_RADIOTAP_FLAGS
	  TX_IEEE80211_RADIOTAP_RATE 
	  TX_IEEE80211_RADIOTAP_CHANNEL
	  TX_IEEE80211_RADIOTAP_FHSS
	  TX_IEEE80211_RADIOTAP_DBM_ANTSIGNAL
	  TX_IEEE80211_RADIOTAP_DBM_ANTNOISE 
	  TX_IEEE80211_RADIOTAP_LOCK_QUALITY 
	  TX_IEEE80211_RADIOTAP_TX_ATTENUATION
	  TX_IEEE80211_RADIOTAP_DB_TX_ATTENUATION 
	  TX_IEEE80211_RADIOTAP_DBM_TX_POWER 
	  TX_IEEE80211_RADIOTAP_ANTENNA 
	  TX_IEEE80211_RADIOTAP_DB_ANTSIGNAL 
	  TX_IEEE80211_RADIOTAP_DB_ANTNOISE 
	  TX_IEEE80211_RADIOTAP_FCS 
	  TX_IEEE80211_RADIOTAP_EXT 
    )],
  network_const => [qw(
  	IF_GET_IFACE
	IF_GET_PROTO
	IF_IFACE_V35
	IF_IFACE_V24
	IF_IFACE_X21
	IF_IFACE_T1
	IF_IFACE_E1
	IF_IFACE_SYNC_SERIAL
	IF_IFACE_X21D
	IF_PROTO_HDLC
	IF_PROTO_PPP
	IF_PROTO_CISCO
	IF_PROTO_FR
	IF_PROTO_FR_ADD_PVC
	IF_PROTO_FR_DEL_PVC
	IF_PROTO_X25
	IF_PROTO_HDLC_ETH
	IF_PROTO_FR_ADD_ETH_PVC
	IF_PROTO_FR_DEL_ETH_PVC
	IF_PROTO_FR_PVC	
	IF_PROTO_FR_ETH_PVC
	IF_PROTO_RAW
	ICMP_ECHOREPLY
	ICMP_DEST_UNREACH
	ICMP_SOURCE_QUENCH
	ICMP_REDIRECT
	ICMP_ECHO
	ICMP_TIME_EXCEEDED
	ICMP_PARAMETERPROB
	ICMP_TIMESTAMP
	ICMP_TIMESTAMPREPLY
	ICMP_INFO_REQUEST
	ICMP_INFO_REPLY
	ICMP_ADDRESS
	ICMP_ADDRESSREPLY
	NR_ICMP_TYPES
	ICMP_NET_UNREACH
	ICMP_HOST_UNREACH
	ICMP_PROT_UNREACH
	ICMP_PORT_UNREACH
	ICMP_FRAG_NEEDED	
	ICMP_SR_FAILED
	ICMP_NET_UNKNOWN
	ICMP_HOST_UNKNOWN
	ICMP_HOST_ISOLATED	
	ICMP_NET_ANO
	ICMP_HOST_ANO
	ICMP_NET_UNR_TOS
	ICMP_HOST_UNR_TOS
	ICMP_PKT_FILTERED
	ICMP_PREC_VIOLATION
	ICMP_PREC_CUTOFF
	NR_ICMP_UNREACH
	ICMP_REDIR_NET
	ICMP_REDIR_HOST
	ICMP_REDIR_NETTOS
	ICMP_REDIR_HOSTTOS
	ICMP_EXC_TTL
	ICMP_EXC_FRAGTIME
	TCP_MSS_DEFAULT
	TCP_MSS_DESIRED
	TCP_NODELAY
	TCP_MAXSEG
	TCP_CORK
	TCP_KEEPIDLE
	TCP_KEEPINTVL
	TCP_KEEPCNT
	TCP_SYNCNT
	TCP_LINGER2
	TCP_DEFER_ACCEPT
	TCP_WINDOW_CLAMP
	TCP_INFO
	TCP_QUICKACK
	TCP_CONGESTION
	TCP_MD5SIG
	TCP_THIN_LINEAR_TIMEOUTS
	TCP_THIN_DUPACK
	TCP_USER_TIMEOUT
	TCP_REPAIR
	TCP_REPAIR_QUEUE
	TCP_QUEUE_SEQ
	TCP_REPAIR_OPTIONS
	TCP_FASTOPEN
	TCP_TIMESTAMP
	TCP_NOTSENT_LOWAT
	TCP_CC_INFO
	TCP_SAVE_SYN
	TCP_SAVED_SYN
	UDP_CORK
	UDP_ENCAP
	UDP_NO_CHECK6_TX
	UDP_NO_CHECK6_RX
	UDP_ENCAP_ESPINUDP_NON_IKE
	UDP_ENCAP_ESPINUDP
	UDP_ENCAP_L2TPINUDP
	IPTOS_TOS_MASK
	IPTOS_LOWDELAY
	IPTOS_THROUGHPUT
	IPTOS_RELIABILITY
	IPTOS_MINCOST
	IPTOS_PREC_MASK
	IPTOS_PREC_NETCONTROL
	IPTOS_PREC_INTERNETCONTROL
	IPTOS_PREC_CRITIC_ECP
	IPTOS_PREC_FLASHOVERRIDE
	IPTOS_PREC_FLASH
	IPTOS_PREC_IMMEDIATE
	IPTOS_PREC_PRIORITY
	IPTOS_PREC_ROUTINE
	IPOPT_COPY
	IPOPT_CLASS_MASK
	IPOPT_NUMBER_MASK
	IPOPT_COPY
	IPOPT_CLASS_MASK
	IPOPT_NUMBER_MASK
	IPOPT_CONTROL
	IPOPT_RESERVED1
	IPOPT_MEASUREMENT
	IPOPT_RESERVED2
	IPVERSION
	MAXTTL
	IPDEFTTL
	IPOPT_OPTVAL
	IPOPT_OLEN
	IPOPT_OFFSET
	IPOPT_MINOFF
	MAX_IPOPTLEN
	IPOPT_NOP
	IPOPT_EOL
	IPOPT_TS
	IPOPT_TS_TSONLY
	IPOPT_TS_TSANDADDR
	IPOPT_TS_PRESPEC
	IPV4_BEET_PHMAXLEN
	IPV6_TLV_TNL_ENCAP_LIMIT
	IPV6_DEFAULT_TNL_ENCAP_LIMIT
	IP6_TNL_F_IGN_ENCAP_LIMIT
	IP6_TNL_F_USE_ORIG_TCLASS
	IP6_TNL_F_USE_ORIG_FLOWLABEL
	IP6_TNL_F_MIP6_DEV
	IP6_TNL_F_RCV_DSCP_COPY
	IP6_TNL_F_USE_ORIG_FWMARK
	IPV6_SRCRT_STRICT
	IPV6_SRCRT_TYPE_0
	IPV6_SRCRT_TYPE_2
	IPV6_OPT_ROUTERALERT_MLD
	RTF_DEFAULT
	RTF_ALLONLINK
	RTF_ADDRCONF
	RTF_PREFIX_RT
	RTF_ANYCAST
	RTF_NONEXTHOP
	RTF_EXPIRES
	RTF_ROUTEINFO
	RTF_CACHE
	RTF_FLOW
	RTF_POLICY
	RTF_PREF_MASK
	RTF_PCPU
	RTF_LOCAL
	RTMSG_NEWDEVICE
	RTMSG_DELDEVICE
	RTMSG_NEWROUTE
	RTMSG_DELROUTE
	IP6_RT_PRIO_USER
	IP6_RT_PRIO_ADDRCONF
  )],
  
  status => [qw(
      WLAN_STATUS_SUCCESS                     
      WLAN_STATUS_UNSPECIFIED_FAILURE         
      WLAN_STATUS_CAPS_UNSUPPORTED            
      WLAN_STATUS_REASSOC_NO_ASSOC            
      WLAN_STATUS_ASSOC_DENIED_UNSPEC         
      WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG      
      WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION    
      WLAN_STATUS_CHALLENGE_FAIL              
      WLAN_STATUS_AUTH_TIMEOUT                
      WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 
      WLAN_STATUS_ASSOC_DENIED_RATES          
      WLAN_STATUS_ASSOC_DENIED_NOSHORT        
      WLAN_STATUS_ASSOC_DENIED_NOPBCC         
      WLAN_STATUS_ASSOC_DENIED_NOAGILITY      
      WLAN_STATUS_INVALID_IE                  
      WLAN_STATUS_GROUP_CIPHER_NOT_VALID      
      WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID   
      WLAN_STATUS_AKMP_NOT_VALID              
      WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION  
      WLAN_STATUS_INVALID_RSN_IE_CAPAB        
      WLAN_STATUS_CIPHER_REJECTED_PER_POLICY  
)],
  iw => [qw(
     LINUX_WLEXT_MONITOR
     LINUX_WLEXT_MASTER
     IW_MAX_PRIV_DEF
   )],
     
  requests => [qw(
     WLAN_FC_SUBTYPE_ASSOCREQ    
     WLAN_FC_SUBTYPE_ASSOCRESP   
     WLAN_FC_SUBTYPE_REASSOCREQ  
     WLAN_FC_SUBTYPE_REASSOCRESP 
     WLAN_FC_SUBTYPE_PROBEREQ    
     WLAN_FC_SUBTYPE_PROBERESP   
     WLAN_FC_SUBTYPE_BEACON      
     WLAN_FC_SUBTYPE_ATIM        
     WLAN_FC_SUBTYPE_DISASSOC    
     WLAN_FC_SUBTYPE_AUTH        
     WLAN_FC_SUBTYPE_DEAUTH      
)],

  rate => [qw(
      LORCON_RATE_DEFAULT     
      LORCON_RATE_1MB               
      LORCON_RATE_2MB               
      LORCON_RATE_5_5MB            
      LORCON_RATE_6MB              
      LORCON_RATE_9MB              
      LORCON_RATE_11MB              
      LORCON_RATE_12MB              
      LORCON_RATE_18MB              
      LORCON_RATE_24MB              
      LORCON_RATE_36MB              
      LORCON_RATE_48MB              
      LORCON_RATE_54MB             
      LORCON_RATE_108MB       
)],

  extrapacket => [qw(
  LORCON_PACKET_EXTRA_NONE
  LORCON_PACKET_EXTRA_80211         
  LORCON_PACKET_EXTRA_8023        
)],
 ieee802_11 => [qw(
 	IEEE80211_MIN_AMPDU_BUF
	IEEE80211_MAX_AMPDU_BUF
	IEEE80211_HT_PARAM_CHA_SEC_OFFSET
	IEEE80211_HT_PARAM_CHA_SEC_NONE
	IEEE80211_HT_PARAM_CHA_SEC_ABOVE
	IEEE80211_HT_PARAM_CHA_SEC_BELOW
	IEEE80211_HT_PARAM_CHAN_WIDTH_ANY
	IEEE80211_HT_PARAM_RIFS_MODE
	IEEE80211_HT_OP_MODE_PROTECTION
	IEEE80211_HT_OP_MODE_PROTECTION_NONE
	IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER
	IEEE80211_HT_OP_MODE_PROTECTION_20MHZ
	IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED
	IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT
	IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT
	IEEE80211_HT_OP_MODE_CCFS2_SHIFT
	IEEE80211_HT_OP_MODE_CCFS2_MASK
	IEEE80211_HT_STBC_PARAM_DUAL_BEACON
	IEEE80211_HT_STBC_PARAM_DUAL_CTS_PROT
	IEEE80211_HT_STBC_PARAM_STBC_BEACON
	IEEE80211_HT_STBC_PARAM_LSIG_TXOP_FULLPROT
	IEEE80211_HT_STBC_PARAM_PCO_ACTIVE
	IEEE80211_HT_STBC_PARAM_PCO_PHASE
	IEEE80211_ADDBA_PARAM_AMSDU_MASK
	IEEE80211_ADDBA_PARAM_POLICY_MASK
	IEEE80211_ADDBA_PARAM_TID_MASK
	IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK
	IEEE80211_DELBA_PARAM_TID_MASK
	IEEE80211_DELBA_PARAM_INITIATOR_MASK
	IEEE80211_HT_CAP_LDPC_CODING
	IEEE80211_HT_CAP_SUP_WIDTH_20_40
	IEEE80211_HT_CAP_SM_PS
	IEEE80211_HT_CAP_SM_PS_SHIFT
	IEEE80211_HT_CAP_GRN_FLD
	IEEE80211_HT_CAP_SGI_20
	IEEE80211_HT_CAP_SGI_40
	IEEE80211_HT_CAP_TX_STBC
	IEEE80211_HT_CAP_RX_STBC
	IEEE80211_HT_CAP_RX_STBC_SHIFT
	IEEE80211_HT_CAP_DELAY_BA
	IEEE80211_HT_CAP_MAX_AMSDU
	IEEE80211_HT_CAP_DSSSCCK40
	IEEE80211_HT_CAP_RESERVED
	IEEE80211_HT_CAP_40MHZ_INTOLERANT
	IEEE80211_HT_CAP_LSIG_TXOP_PROT
	IEEE80211_HT_EXT_CAP_PCO
	IEEE80211_HT_EXT_CAP_PCO_TIME
	IEEE80211_HT_EXT_CAP_PCO_TIME_SHIFT
	IEEE80211_HT_EXT_CAP_MCS_FB
	IEEE80211_HT_EXT_CAP_MCS_FB_SHIFT
	IEEE80211_HT_EXT_CAP_HTC_SUP
	IEEE80211_HT_EXT_CAP_RD_RESPONDER
	IEEE80211_FCTL_VERS
	IEEE80211_FCTL_FTYPE
	IEEE80211_FCTL_STYPE
	IEEE80211_FCTL_TODS
	IEEE80211_FCTL_FROMDS
	IEEE80211_FCTL_MOREFRAGS
	IEEE80211_FCTL_RETRY
	IEEE80211_FCTL_PM
	IEEE80211_FCTL_MOREDATA
	IEEE80211_FCTL_PROTECTED
	IEEE80211_FCTL_ORDER
	IEEE80211_FCTL_CTL_EXT
	IEEE80211_SCTL_FRAG
	IEEE80211_SCTL_SEQ
	IEEE80211_FTYPE_MGMT
	IEEE80211_FTYPE_CTL
	IEEE80211_FTYPE_DATA
	IEEE80211_FTYPE_EXT
	IEEE80211_STYPE_ASSOC_REQ
	IEEE80211_STYPE_ASSOC_RESP
	IEEE80211_STYPE_REASSOC_REQ
	IEEE80211_STYPE_REASSOC_RESP
	IEEE80211_STYPE_PROBE_REQ
	IEEE80211_STYPE_PROBE_RESP
	IEEE80211_STYPE_BEACON
	IEEE80211_STYPE_ATIM
	IEEE80211_STYPE_DISASSOC
	IEEE80211_STYPE_AUTH
	IEEE80211_STYPE_DEAUTH
	IEEE80211_STYPE_ACTION
	IEEE80211_STYPE_CTL_EXT
	IEEE80211_STYPE_BACK_REQ
	IEEE80211_STYPE_BACK
	IEEE80211_STYPE_PSPOLL
	IEEE80211_STYPE_RTS
	IEEE80211_STYPE_CTS
	IEEE80211_STYPE_ACK
	IEEE80211_STYPE_CFEND
	IEEE80211_STYPE_CFENDACK
	IEEE80211_STYPE_DATA
	IEEE80211_STYPE_DATA_CFACK
	IEEE80211_STYPE_DATA_CFPOLL
	IEEE80211_STYPE_DATA_CFACKPOLL
	IEEE80211_STYPE_NULLFUNC
	IEEE80211_STYPE_CFACK
	IEEE80211_STYPE_CFPOLL
	IEEE80211_STYPE_CFACKPOLL
	IEEE80211_STYPE_QOS_DATA
	IEEE80211_STYPE_QOS_DATA_CFACK
	IEEE80211_STYPE_QOS_DATA_CFPOLL
	IEEE80211_STYPE_QOS_DATA_CFACKPOLL
	IEEE80211_STYPE_QOS_NULLFUNC
	IEEE80211_STYPE_QOS_CFACK
	IEEE80211_STYPE_QOS_CFPOLL
	IEEE80211_STYPE_QOS_CFACKPOLL
	IEEE80211_STYPE_DMG_BEACON
	IEEE80211_CTL_EXT_POLL
	IEEE80211_CTL_EXT_SPR
	IEEE80211_CTL_EXT_GRANT
	IEEE80211_CTL_EXT_DMG_CTS
	IEEE80211_CTL_EXT_DMG_DTS
	IEEE80211_CTL_EXT_SSW
	IEEE80211_CTL_EXT_SSW_FBACK
	IEEE80211_CTL_EXT_SSW_ACK
	WLAN_MAX_KEY_LEN
	WLAN_PMK_NAME_LEN
	WLAN_PMKID_LEN
	WLAN_PMK_LEN_EAP_LEAP
	WLAN_PMK_LEN
	WLAN_PMK_LEN_SUITE_B_192
	WLAN_OUI_WFA
	WLAN_OUI_TYPE_WFA_P2P
	WLAN_OUI_MICROSOFT
	WLAN_OUI_TYPE_MICROSOFT_WPA
	WLAN_OUI_TYPE_MICROSOFT_WMM
	WLAN_OUI_TYPE_MICROSOFT_WPS
	WLAN_OUI_TYPE_MICROSOFT_TPC
	IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895
	IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991
	IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454
	IEEE80211_VHT_CAP_MAX_MPDU_MASK
	IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ
	IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ
	IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK
	IEEE80211_VHT_CAP_RXLDPC
	IEEE80211_VHT_CAP_SHORT_GI_80
	IEEE80211_VHT_CAP_SHORT_GI_160
	IEEE80211_VHT_CAP_TXSTBC
	IEEE80211_VHT_CAP_RXSTBC_1
	IEEE80211_VHT_CAP_RXSTBC_2
	IEEE80211_VHT_CAP_RXSTBC_3
	IEEE80211_VHT_CAP_RXSTBC_4
	IEEE80211_VHT_CAP_RXSTBC_MASK
	IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE
	IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE
	IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT
	IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT
	IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE
	IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE
	IEEE80211_VHT_CAP_VHT_TXOP_PS
	IEEE80211_VHT_CAP_HTC_VHT
	IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT
	IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_UNSOL_MFB
	IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB
	IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN
	IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN
 	NULL
 )],
  channel => [qw(
      LORCON_CHANNEL_BASIC
      LORCON_CHANNEL_HT20
      LORCON_CHANNEL_HT40P
      LORCON_CHANNEL_HT40M
      LORCON_CHANNEL_5MHZ
      LORCON_CHANNEL_10MHZ
      LORCON_CHANNEL_VHT80
      LORCON_CHANNEL_VHT160
      LORCON_CHANNEL_VHT8080
)],
  
  wifi_mask => [qw(
      WIFI_WIDTH_MASK 
      WIFI_HT_MASK 
      WIFI_OTHER_MASK 

)],
  wifi_commands => [qw(
	get_wiphy
	set_wiphy
	new_wiphy
	del_wiphy
	get_interface
	set_interface
	new_interface
	del_interface
	get_key
	set_key
	new_key
	del_key
	get_beacon
	set_beacon
	start_ap
	stop_ap
	get_station
	set_station
	new_station
	del_station
	get_mpath
	set_mpath
	new_mpath
	del_mpath
	set_bss
	set_reg
	req_set_reg
	get_mesh_config
	set_mesh_config
	get_reg
	get_scan
	trigger_scan
	new_scan_results
	scan_aborted
	reg_change
	authenticate
	associate
	deauthenticate
	disassociate
	michael_mic_failure
	reg_beacon_hint
	join_ibss
	leave_ibss
	testmode
	connect
	roam
	disconnect
	set_wiphy_netns
	get_survey
	new_survey_results
	set_pmksa
	del_pmksa
	flush_pmksa
	remain_on_channel
	cancel_remain_on_channel
	set_tx_bitrate_mask
	register_frame
	frame
	frame_tx_status
	set_power_save
	get_power_save
	set_cqm
	notify_cqm
	set_channel
	set_wds_peer
	frame_wait_cancel
	join_mesh
	leave_mesh
	unprot_deauthenticate
	unprot_disassociate
	new_peer_candidate
	get_wowlan
	set_wowlan
	start_sched_scan
	stop_sched_scan
	sched_scan_results
	sched_scan_stopped
	set_rekey_offload
	pmksa_candidate
	tdls_oper
	tdls_mgmt
	unexpected_frame
	probe_client
	register_beacons
	unexpected_4addr_frame
	set_noack_map
	ch_switch_notify
	start_p2p_device
	stop_p2p_device
	conn_failed
	set_mcast_rate
	set_mac_acl
	radar_detect
	get_protocol_features
	update_ft_ies
	ft_event
	crit_protocol_start
	crit_protocol_stop
	get_coalesce
	set_coalesce
	channel_switch
	vendor
 )],
   lorcon => [qw(
      is_compatible_with_formal_logic
      lorcon_get_version
      lorcon_list_drivers
      lorcon_find_driver
      lorcon_create
      lorcon_free_driver_list
      lorcon_free
      lorcon_set_timeout
      lorcon_get_timeout
      lorcon_open_monitor
      lorcon_open_injmon
      lorcon_set_vap
      lorcon_get_vap
      lorcon_get_capiface
      lorcon_auto_driver
      lorcon_get_driver_name
      lorcon_get_error
      lorcon_packet_from_pcap
      lorcon_open_inject
      lorcon_send_bytes
      lorcon_get_useraux
      lorcon_set_useraux
      lorcon_packet_free
      lorcon_packet_decode
      lorcon_packet_set_channel
      lorcon_packet_get_channel
      lorcon_packet_txprep_by_ctx
      lorcon_loop 
      lorcon_packet_to_dot3
      lorcon_set_hwmac
      lorcon_get_hwmac
      lorcon_multi_remove_interface_error_handler
      lorcon_multi_interface_get_lorcon
      lorcon_multi_get_next_interface
      lorcon_multi_get_interfaces
      lorcon_multi_del_interface
      lorcon_multi_add_interface
      lorcon_multi_free
      lorcon_multi_create
      lorcon_get_complex_channel 
      lorcon_set_complex_channel
      lorcon_ifdown
      locon_packet_get_bssid_mac
      lorcon_packet_get_dest_mac
      lcpf_randmac
      lorcon_packet_get_source_mac
      lorcon_ifup
      lorcon_breakloop
      lorcon_set_filter
      lorcon_next_ex
      lorcon_parse_ht_channel
      lorcon_get_selectable_fd
      lorcon_packet_set_freedata
      lorcon_set_compiled_filter
      lorcon_get_pcap
      drv_madwifing_init
      drv_madwifing_listdriver
      lorcon_close
      lorcon_inject
      lorcon_add_wepkey
      aj_xmitframe
      aj_setmac
      aj_setchannel
      aj_setmode
      aj_setmonitor
      _lorcon_copy_driver
      lorcon_set_channel
      lorcon_get_channel
      lorcon_airjack_listdriver
      lorcon_airjack_init
      iwconfig_set_mode
      iwconfig_get_mode
      iwconfig_set_channel
      iwconfig_get_channel
      iwconfig_get_name
      iwconfig_get_ssid
      iwconfig_set_ssid
      iwconfig_set_intpriv
      nl80211_find_parent
      nl80211_setfrequency_cache
      nl80211_setfrequency
      nl80211_setchannel
      nl80211_setchannel_cache
      nl80211_createvif
      nl80211_disconnect
      nl80211_connect
      tx80211_airpcap_capabilities
      tx80211_airpcap_init 
      drv_file_listdriver
      drv_rtfile_init
      drv_file_init
      drv_tuntap_listdriver
      drv_tuntap_init
      tx80211_hostap_capabilities
      tx80211_hostap_init
      tx80211_mac80211_capabilities
      drv_mac80211_listdriver
      drv_mac80211_init
      mac80211_ifconfig_cb
      RMAC_gen
      RString_Gen
      Create
      Version
      Close
      IWconfig
      lcpa_init
      lcpa_append
      lcpa_append_copy
      lcpa_insert
      lcpa_find_name
      lcpa_replace_copy
      lcpa_replace
      lcpa_free
      lcpa_size
      lcpa_freeze
      madwifing_getmac_cb
      madwifing_setmac_cb
      madwifing_sendpacket
      madwifing_list_vaps
      madwifing_free_vaps
      madwifing_destroy_vap
      madwifing_build_vap
      madwifing_setdevtype
      madwifing_find_parent
      ifconfig_get_sysdriver
      ifconfig_get_sysattr
      ifconfig_set_flags
      ifconfig_delta_flags
      ifconfig_get_flags
      ifconfig_get_hwaddr
      ifconfig_set_hwaddr
      ifconfig_set_mtu
      ifconfig_ifupdown
      wtinj_send
      wtinj_open
      wtinj_close
      wtinj_setchannel
      wtinj_getchannel
      wtinj_setmode
      wtinj_getmode
      wtinj_setfuncmode
      wtinj_selfack 
      tx80211_zd1211rw_init
      tx80211_zd1211rw_send
      tx80211_zd1211rw_capabilities
      lcpf_80211headers
      lcpf_qos_data
      lcpf_beacon
      lcpf_deauth
      lcpf_add_ie
      lcpf_disassoc
      lcpf_probereq
      lcpf_proberesp
      lcpf_rts
      lcpf_80211ctrlheaders
      lcpf_authreq
      lcpf_authresq
      lcpf_assocreq
      lorcon_packet_get_interface
      lorcon_packet_get_llc_type
      lorcon_packet_get_bssid_mac
      lorcon_packet_get_dest_mac
      lorcon_packet_get_source_mac
      lorcon_packet_get_dot3_extra
      lorcon_packet_get_dot11_extra
      lorcon_packet_from_dot3
      lorcon_packet_to_dot3
      lorcon_packet_set_mcs
      lorcon_packet_from_lcpa
      Open_Monitor
      Open_Inject
      Open_Injmon
      Inject_Frame
      Send_Bytes
      ChangeMAC
      add_WEPKey
      tuntap_openmon_cb
      tuntap_sendbytes
      lcpa_freeze
      lcpa_size
      Packet_to_hex
      Hex_to_packet
      wginj_send
      tx80211_getcardlist
      tx80211_freecardlist
      drv_mac80211_probe
      drv_file_probe
      mac80211_openmon_cb
      mac80211_setchan_cb
      Detect_Driver
      rtfile_pcap_handler
      file_openmon_cb
      tx80211_rt61_init
      tx80211_rt61_capabilities
      rt61_open
      tx80211_prism54_init
      tx80211_prism54_capabilities
      Channel_to_Frequency
      Frequency_to_Channel      
      channel_to_frequency_HASH
      dissociation_reason_codes_HASH
      association_reason_codes_HASH
      wginj_close
      wginj_open
      mac80211_sendpacket
      nl80211_get_chanlist
      nl80211_error_cb
      bcm43xx_close
      bcm43xx_open
      tx80211_bcm43xx_init
      pcap_get_selectable_fd
      pcap_datalink
      pcap_sendpacket
      pcap_inject
      pcap_can_set_rfmon      
      lorcon_multi_loop
      madwifing_openmon_cb   
      wginj_getchannel
      wginj_setchannel
      wginj_getmode
      wginj_setmode
      tx80211_wlanng_capabilities
      tx80211_wlanng_init     
      tx80211_initpacket
      tx80211_setlocaldlt
      tx80211_getdlt
      tx80211_getdrivername
      tx80211_init
      tx80211_airjack_capabilities
      tx80211_rtl8180_init
      tx80211_get_capabilities
      pcap_set_rfmon 
      tx80211_txpacket
      tx80211_setmodulation
      tx80211_getmodulation
      tx80211_setfunctionalmode
      tx80211_setchannel
      tx80211_getchannel
      tx80211_open
      tx80211_close
      tx80211_decodepkt
      nl80211_ack_cb
      floatchan2int
      iwfreq2float
      tx80211_rt73_init
      tx80211_rt73_capabilities
      rt73_open
      rt73_close
      tx80211_rt2500_init
      tx80211_rt2500_capabilities
      rt2500_open
      rt2500_close
      aj_setnonblock
      aj_getnonblock
      aj_getsocket
      aj_ifupdown
      lorcon_supported_cards
      lorcon_actual_cards
      tx80211_selfack 
      tx80211_gettxrate 
      tx80211_settxrate 
      tx80211_setfunctionalmode 
      tx80211_getmode 
      tx80211_resolvecard 
      tx80211_resolveinterface 
      tx80211_geterrstr 
      tx80211_setmode
      FindLinkage
      tx80211_meta
      tx80211_free
      tx80211_packet_meta 
      filter_dissociation_codes
      filter_association_codes
      tx80211_decodepkt
      ajinj_open
      ajinj_close      
      lcpf_assocresp
      lcpf_data
      lcpf_qosheaders
      tx80211_decodepacket 
      apitest_packet_hdlr
 )],
 
   suites => [qw(
       WEP40
       WEP104
       CCMP
       TKIP
       EAP
       PSK
   )],
   crypto => [qw(
   	sha1_meta
	sha1_hmac_meta 
   	sha1_process
   	sha1_update
   	sha1_finish
	sha1_starts
	sha1_hmac_starts
	sha1_hmac_update
	sha1_hmac_finish
	sha1_hmac
   )],
   reaver =>[qw(
   	build_radio_tap_header
   	get_wps
   	get_ap_capability
   	reaver_set_channel
	get_channel
	set_bssid
	build_wps_probe_request
	build_association_management_frame
	build_authentication_management_frame
	build_snap_packet
	build_eap_packet
	globule_init
	globule_deinit
	build_eapol_start_packet
	assoc_request_meta
	assoc_response_meta
	beacon_management_meta
	auth_management_meta
	build_dot1X_header
	build_eap_failure_packet
	build_tagged_parameter
	build_wps_tagged_parameter
	reaver_inject
	wps_data_to_json
	libwps_meta
	send_generic_packet 
	send_packet_internal
	)],
   wps_constants => [qw(
   	FAKE_RADIO_TAP_HEADER
	TAG_SUPPORTED_RATES
	TAG_EXT_RATES
	TAG_HT_CAPS
	WPS_PROBE_IE
	WPS_VENDOR_ID
	WPS_DEVICE_TYPE
	WPS_OS_VERSION
	DEFAULT_UUID
	WFA_REGISTRAR
	WPA_IE_ID
	WFA_VENDOR_ID
	NULL_MAC
	WPS_REGISTRAR_TAG
	
	)],
     packet_checksum => [qw(
     packet_crc
     packet_entropy
     )],
     physical => [qw(
     	mw_to_dbm
     	dbm_to_mw
     
     )],
     osdep => [qw(
       wi_read
       wi_write
       wi_set_channel
       wi_get_channel 
       wi_get_freq
       wi_set_freq
       wi_get_monitor
       wi_get_ifname
       wi_close
     
     )],
);

# _pcap_check_activate has been eliminated due to debug errors
our @EXPORT = (
   @{ $EXPORT_TAGS{ consts } },
   @{ $EXPORT_TAGS{ lorcon } },
   @{ $EXPORT_TAGS{ osdep } },
   @{ $EXPORT_TAGS{ channel } },
   @{ $EXPORT_TAGS{ extrapacket } },
   @{ $EXPORT_TAGS{ rate } },
   @{ $EXPORT_TAGS{ status } },
   @{ $EXPORT_TAGS{ radiotap } },
   @{ $EXPORT_TAGS{ requests } },
   @{ $EXPORT_TAGS{ wifi_mask } },
   @{ $EXPORT_TAGS{ tx_80211 } },
   @{ $EXPORT_TAGS{ network_const } },
   @{ $EXPORT_TAGS{ ieee802_11 } },
   @{ $EXPORT_TAGS{ suites } },
   @{ $EXPORT_TAGS{ ioctls } },
   @{ $EXPORT_TAGS{ wifi_commands } },
   @{ $EXPORT_TAGS{ rx_frames } },
   @{ $EXPORT_TAGS{ iw } },
   @{ $EXPORT_TAGS{ crypto } },
   @{ $EXPORT_TAGS{ reaver } },
   @{ $EXPORT_TAGS{ wps_constants } },
   @{ $EXPORT_TAGS{ packet_checksum } },
   @{ $EXPORT_TAGS{ physical } },
);

# NOTE:
# for lorcon_set_filter & co is extremely suggested  refer to the following links:
#	https://wiki.infinetwireless.com/display/DR/PCAP-filters
#	https://www.ibm.com/support/knowledgecenter/SS9H2Y_7.7.0/com.ibm.dp.doc/pcap_filterexpressionsyntax.html
#	https://man.openbsd.org/pcap-filter.5

# FindLinkage will parse the /sys/class/net/ folder and search for wireless driver folder name

sub FindLinkage(){ 
if( readlink("/sys/class/net/wlo1/device/driver") ){
		return("/sys/class/net/wlo1/device/driver");
}elsif( readlink("/sys/class/net/wlan0/device/driver") ){
		return("/sys/class/net/wlan0/device/driver");
	}else{ # plain B, search for a driver with "w" character
		my @linked_list = ` ls /sys/class/net/ `;
		foreach(@linked_list){
			if($_ =~ "w"){
				return($_);
		}
}
	}
			}
			
# Detect_Driver uses FindLinkage for having the good link and split the string for obtaining the driver name
sub Detect_Driver(){
	my $linked_drv = readlink(&FindLinkage() );
	my @driver = split(/\//, $linked_drv);
	return($driver[-1]); 
}


sub RString_Gen(){ # adapted string for MAC address
  my @chars = ("a".."f", 0 .. 9);
  my $string;
  $string .= $chars[rand @chars] for 1..12;
  return($string);
}

sub RMAC_gen(){
  my $raw_mac = (Net::MAC->new('mac' => &RString_Gen(), 'die' => 0) );
  my $formatted_mac = $raw_mac->convert(
    'bit_group' => 8,  
    'delimiter' => ':'
);
  return ($formatted_mac);

}

# Convert an ASCII string to Hex, consider the string a possible Network Packet
sub Packet_to_hex{
	my $Packet = shift;
	$Packet =~ s/(.)/sprintf "%4x", ord $1/seg;
	$Packet =~ s/[[:space:]]/\\x/g;
	$Packet =~ s/\\x\\//g;
	$Packet =~ s/x/\\x/g;
	# delete garbage from $string
	return( $Packet );
}
# Decode an hex string to an ascii value, consider the hex a possible Network Packet
sub Hex_to_packet{
	my $HEX = shift;
	$HEX =~ s/\\x((?:[0-9a-fA-F]{2})+)/pack 'H*', $1/ge;
	return( $HEX );
}

# create context
sub create(){
   my ( $interface, $driver ) = @_;
   my $drv = lorcon_find_driver( $driver ) or die $!;
   if( ( lorcon_create( $interface, $drv ) ) == -1 ){
      return -1; 
   }else{
      return 0;
}
   }
   
# return version
sub version(){
   return ( lorcon_get_version() );
}

# shutdown lorcon
sub kill_lorcon(){
   my $context = @_;
   if( ( lorcon_close( $context ) ) == -1 ){
      return -1;
   }else{
      return 0;   
}

   }

sub Open_Monitor { # Open monitor mode, tries with both libpcap and lorcon2
    my $context = @_;
    my $pcap = lorcon_get_pcap( $context );
    if( pcap_can_set_rfmon( $pcap ) == -1 ){
    	return -1;
    }else{
    if(! ( lorcon_open_monitor( $context ) ) ){
	return -1; # Bad 
     }else{
        return 1;   # Good
}
    }
    	}
    
sub Open_Inject { # Open inject mode
    my $context = @_;
    if(! ( lorcon_open_inject( $context ) ) ){
        return -1; # Bad
    }else{
        return 1; # Good
}
    }
    
sub Open_Injmon { # Open both
    my $context = @_;
    if(! ( lorcon_open_injmon( $context ) ) ){
        return -1; # Bad
    }else{
        return 1; # Good
    }
}

# use syscall for changing mac address
sub ChangeMAC {
	require Net::MAC;
	my ($interface, $MAC) = @_;
	# Prevention against malformed MAC's
	my $control = Net::MAC->new('mac' => $MAC, 'die' => 0); # Die if MAC is wrong
	delete $INC{'Net/MAC.pm'}; # toggle module from %INC
	`ip link set dev interface down`; # set interface to down (0)
        if(`sudo ip link set dev $interface address $MAC`){
		if( `sudo ip link set dev $interface up` ){
			return 0;
	}else{
		return -1;
}
	}
		}
	
sub Inject_Frame {
    my ($context, $packet) = @_;
    return( lorcon_inject($context, $packet) );
}
   
sub Send_Bytes {
    my ($context, $packet ) = @_;
    my $length = length($packet);
    return( lorcon_send_bytes($context, $length, \$packet) );
}

# semplified iwconfig functions
# =============================

sub setSSID{
  my ( $input_device, $error_string, $essid ) = @_; 
  return( iwconfig_set_ssid(\$input_device, \$error_string, \$essid) );
}
  
sub getSSID{
  my ( $input_device, $error_string, $essid ) = @_; 
  return( iwconfig_get_ssid(\$input_device, \$error_string, \$essid) );
}

sub getNetworkName{
  my ( $input_device, $error_string, $input_name ) = @_; 
  return ( iwconfig_get_name( \$input_device, \$error_string, \$input_name) );
}

sub getChannel{
  my ( $input_device, $error_string ) = @_; 
  return( iwconfig_get_channel( \$input_device, \$error_string ) );
}

sub setChannel{
  my ( $input_device, $error_string, $channel ) = @_; 
  return( iwconfig_set_channel(\$input_device, \$error_string, $channel ) );
}

sub getMode{
  my ( $input_device, $error_string ) = @_; 
  return( iwconfig_get_mode(\$input_device, \$error_string ) );
}

sub setMode{
  my ( $input_device, $error_string, $mode ) = @_; 
  return( iwconfig_set_mode(\$input_device, \$error_string, $mode ) );
}

# DISCOURAGED: automatically initialize driver 
sub auto_Initialize_driver{
	my ( $context, $prefferred_drive ) = @_;
	if(undef($prefferred_drive)){
		my @supported_drivers = ("madwifing", "mac80211");
		my $drivers_list = lorcon_list_drivers();
		foreach (@{ $drivers_list }){
		  if($_ =~ $supported_drivers[0]){
			if( drv_madwifing_init( $context ) ){
				return 1;
			}
 	}elsif($_ =~ $supported_drivers[1]){
			if( drv_mac80211_init( $context ) ){
				return 1;
			}
}
	}
	}
}

# simplified lorcon_add_wepkey function
sub add_WEPKey {
	my ($context, $bssid, $WEPkey) = @_;
	return( lorcon_add_wepkey($context, $bssid, $WEPkey, length($WEPkey) ) );

}

# these 2 functions return a reference for the %channel_to_frequency and %reason_codes hashes
sub channel_to_frequency_HASH(){
	foreach( keys %channel_to_frequency ){
		print "channel : $_ -> $channel_to_frequency{ $_ }\n";
	}
}

# these 2 functions drop the reference for the dissociation and association reason codes required for lcpf functions
sub dissociation_reason_codes_HASH(){
	foreach( keys %dissociation_reason_codes ){
		print "$_ => dissociation_reason_codes{ $_ }\n";
	}
}

sub association_reason_codes_HASH(){
	foreach( keys %association_reason_codes ){
		print "$_ => association_reason_codes{ $_ }\n";
	}
}

# filter_dissociation_codes and filter_association_codes will fetch a given word and search through the hashes, returning the identificative number

sub filter_dissociation_codes{
	my $word = @_;
	if( length( $word ) <= 3 ){
		print "word too short!\n";
		return -1;
	}
	foreach( keys %dissociation_reason_codes ){
		if( $word =~ $dissociation_reason_codes{ $_ } ){
			return $_;
		}
	}

}

sub filter_association_codes{
	my $word = @_;
	if( length( $word ) <= 3 ){
		print "word too short!\n";
		return -1;
	}
	foreach( keys %association_reason_codes ){
		if( $word =~ $association_reason_codes{ $_ } ){
			return $_;
		}
	}

}

# as their name suggest, these 2 functions permits the conversion from channel to its frequency and vice-versa, is suggested to use them with 
# Lorcon_set_channel (or similar) functions

sub Channel_to_Frequency{
        my $channel = shift;
	if( defined( $channel_to_frequency{ $channel } ) ){
        	return $channel_to_frequency{ $channel };
	}
}

sub Frequency_to_Channel{
        my $Frequency = shift;
        return (grep { $channel_to_frequency{$_} eq $Frequency } keys %channel_to_frequency );
        }

# show every supported driver by Lorcon2 in a clear way
sub lorcon_supported_cards {
	my %tx80211 = tx80211_getcardlist();
	foreach( keys %tx80211 ){
		print "$_ => $tx80211{ $_ }\n";
	}
}

# this will dump supported lorcon drivers supported by host, output is similar to lorcon_supported_cards function
sub lorcon_actual_cards {
	my $driver = lorcon_list_drivers();
	foreach( @{ $driver } ){
		my %r = %{ $_ };
		foreach( keys %{ $_ } ){
			print $_ . " => " . $r{ $_ };
			print "\n";
		}
	print "\n";
	}
}	

# for infos see: https://www.electronicdesign.com/technologies/communications/article/21796484/understanding-wireless-range-calculations
# convert mW to dBm

sub mw_to_dbm {
	my $mw = @_;
	return( 10 *log( $mw ) ); # our dBm converted value
}

sub dbm_to_mw {
	my $dbm = @_;
	return( 10 ** ( $dbm / 10 ) ); # our mW converted value
}


sub parse_differential{
	my ( $Packet, $Packet1 ) = @_;
	my $i = 0;
	my $str;
	if( undef($Packet) || undef($Packet1) ){
		return -1;
	}
	my @parsed_differentials = calculate_differential($Packet, $Packet1);
	while( $i <= $#parsed_differentials ){
		$str .= $parsed_differentials[$i];
		$i++ if($i <= $#parsed_differentials);
	}
	return($str);
}

__PACKAGE__->bootstrap($VERSION);

1;




